# Install Notes

First, we're going to use conda which is the same environment management tool pytorch uses. It's really for us a wrapper on a specific python version and allows us to use pip installs without affecting any other projects. 

$ conda activate enigma-bombe

Then make sure to install all the items listed in pyproject.toml. The ".[dev]" argument installs all options in the [project.optional-dependencies] section. 

$ pip install --editable ".[dev]" 

You can then run two options: run the command line versions or the dockerized API version

## Comannd Line Version

First, run the unit tests to make sure the system works

$ python -m pytest -v test/unit

Then you can run the code quality tools 

like linting

$ python -m pylint src/ --disable=C0114,C0116,R1705

like black to autofix some linting issues

$ python -m black src/ --check 

$ python -m black src/

## Install pytorch tasks

After spacy is installed, download the english model to tokenize 

python -m spacy download en_core_web_sm

## Brute force cracking messages

Using brute force, we can crack simplified enigma machine messages. This will try all combinations of rotors and offsets to generate text. The challenge here is to score unciphered text. This is done two ways: using [Index of Coincidence](https://en.wikipedia.org/wiki/Index_of_coincidence) and secondly using a trie to count the number of words found in a corresponding dictionary. 

The attack code is run via 

$ python cipher_attack.py

which will pick a message from data/messages.txt, cipher it using a random set of rotors and offsets then brute force a solution. The Top-k items are then printed out for the given metrics (IoC, Percent Words), 

## Machine Learning to help idenitify rotors

In the 1930s, [Polish mathematicians](https://en.wikipedia.org/wiki/Marian_Rejewski) used cycles to identify the rotors used in each day's configuration. I was curious if a machine learning approach could learn to identify rotors and built an [RNN model](https://pytorch.org/tutorials/intermediate/char_rnn_classification_tutorial.html) to identify rotors used. 

First, you will need to generate some cypher messages from a given text. In this case, I chose the 1916 [Manual for the Solution of Military Ciphers](https://www.gutenberg.org/files/48871/48871-h/48871-h.htm) by Parker Hitt. First, we broke it into 

$ python src/enigma_bombe/learn_cipher_data.py

The goal was to make it easy to generate data for new configurations. In the first example, I used none to represent unciphered text and identity to represent the simple Ceasar cipher that is represented by an enigma machine with only a reflector ring. We can break the dataset into sentences of maximum length 250 characters but the exact length will vary. There's an open question if we need to analyze a full days worth of text or if the short messages will work. 

    cds = CipherDatasetGenerator(message_length=250)
    cds.add_class("identity", rotors=[identity, identity, identity], offset=[0,0,0])
    cds.add_class("none", rotors=None, offset=None)    

    cds.append_examples("data/cipher_book_full.txt") 
    #cds.append_examples("data/moby.dick.txt")
    
    cds.write_dataset("data/learning")

The next task is taking that data and learning to predict a model from it. RNNs are ideal for this type of analysis as the data items vary in length and sequence is important. You can learn a model with the following command. 

$ python src/enigma_bombe/learn_cipher_rnn.py 

The script will load all text files in data/learning (generated by the learn_ciper_data.py script), build a model and output a loss chart and a confusion matrix. You can change the number of epochs, mini batch size, learning rate and criterion. 

# Resources

Here's the [paper](https://web.archive.org/web/20060720040135/http://members.fortunecity.com/jpeschel/gillog1.htm) that we will base our attack of enigma cipher text on using the  [Index of Coincidence](https://en.wikipedia.org/wiki/Index_of_coincidence)


A [great RealPython resource](https://realpython.com/docker-continuous-integration/) to start using redis, python and docker together is on RealPython. I modified this a fair bit to get the behavior I wanted for a dockerized API. 


